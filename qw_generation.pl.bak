%QW GENERATION BY RELATIONS COMBINATIONS

%Functor called by the main directive (e.g., test/2)
%[diapo 'QW Generation algorithm']
%PARAMETERS
%[+]Relations: List of relations
%[+]Functions: List of functions
%[?]Function: resulting function of the form 
%		function(id,
%			 Aliases,
%			 Expression,
%			 Projection,
%			 QW) // This is not part of the function definition but is used to
%			     //carry the query workflow composition through the function reduction
%
%DESCRIPTION:
% The generate_qw_by_Relations(Relations,Functions,Function) succeds if the Function is a 
%reduction of the functions of Functions which relations among them are Relations
generate_qw_by_Relations(Relations,Functions,Function):-
	permutation(Relations,RelationsPermuted), %permutations of the Relations
	clear_dtf_ids,			%empties the function ids created during the reduction
	nl,write('   PERM: '),
        findall(_,(nth(_,RelationsPermuted,Rel)
                   ,print_relation_short(Rel,Output),
                    write(Output),write(', ')
                  ),_),
	do_generate_qw_by_Relations(RelationsPermuted,Functions,Function,2). %this is the core of the algo [diapo 'QW Generation algorithm']

%Functor called by generate_qw_by_Relations/3
%[diapo 'QW Generation algorithm']
%PARAMETERS
%[+]Relations: cf. generate_qw_by_Relations/3
%[+]Functions: cf. generate_qw_by_Relations/3
%[?]Function: cf. generate_qw_by_Relations/3
%[+]Level: integer with the level of the reduction. Just for presentation purposes
%
%DESCRIPTION: This is the core of the generation algorithm cf.generate_qw_by_Relations/3
do_generate_qw_by_Relations(_,[Function],Function,_). %base case: if there is only one function in the Functions thus it has finished

do_generate_qw_by_Relations(Relations,Functions,Function,Level):-
	length(Functions,L), L>1,

	Relations=[Relation|_], %picks the first relation


%+Presentation purposes
	nl,write('============================================'),
	nl,write('\t FUNCTIONS:\n\t\t'),
	findall(_,(nth(_,Functions,Fun)
		   ,print_function_short(Fun,Output),
	 	   write(Output),write(', ')
	          ),_),
	nl,write('\t RELATIONS:'),
	findall(_,(nth(_,Relations,Rel)
		  ,print_relation_short(Rel,Output),
	 	   nl,write('\t\t'),write(Output)
	          ),_),
	nl,write('\t MATRIX:'),
	print_matrix_of_relations(Relations,2),
	nl,write('\t CHOSEN RELATION: '),print_relation_short(Relation),
%-Presentation purposes
	Relation=..[RelationType,F1,F2], %gets the relation type and the related functions
	arg(1,F1,Id1), %gets the id of the first function
	arg(1,F2,Id2), %gets the id of the second function

	merge_dtfs(F1,F2,NewFunction), %merge(f1,f2) ['Merging functions`]
	difference(Functions,[F1,F2],RestOfFunctions), %removes both functions of the relation from the Functions list

	findall(Rel,(	nth(_,RestOfFunctions,OtherF), %for each reminding function, the relations with the NewFunction are calculated
                      	do_relations([[NewFunction,OtherF]],[Rel]),
			\+Rel=..[fail|_] 	%if the resulted relation has a type 'fail' thus there is an anomaly
        		),NewRelationsWithNewFunction),
	length(RestOfFunctions,N),			%  Both listes must have the same cardinality N
	length(NewRelationsWithNewFunction,N),!,	%otherwise it was at least one error 'fail' (e.g. deadlock [diapo 'Deadlock patterns'])

%+Presentation purposes
	print_relation_derivation(Relation,NewFunction,Relations,NewRelationsWithNewFunction),
%-Presentation purposes

	arg(1,NewFunction,IdNew), %gets the id of the new function
	arg(6,NewFunction,SubQW), %  gets SubQW variable. When the NewFunction is created SubQW is
				  %unbounded (i.e, it has no an associated quwey workflow (c.f. compose_qw/4)
	qw_pattern(RelationType,CompositionPattern), %  chose a composition pattern according with the
					     %RelationType [diapo 'Composition patterns', 'QW Generation algorithm']
	compose_qw(CompositionPattern,F1,F2,SubQW), %  The subquery workflows of F1 and F2 are joined to
						 %the composition pattern. Thus the SubQW is bounded with the new QW

%+Presentation purposes
 	nl,write('\t        NEWFUNCTION: '),write('\t'),write(IdNew),write(' = merge('),write(Id1),write(', '),write(Id2),write(')'),
 	                                    %nl,write('\t\t'),write(NewFunction),
	nl,write('\t          QW:'),write('\t'),write(SubQW),
%-Presentation purposes

	NewFunctionSet=[NewFunction|RestOfFunctions], %The NewFunction is added to the rest of functions
	findall(Rel,(nth(_,Relations,Rel),		%Gets the non-adjacent relations
		     Rel=..[_,FLeft,FRight],
		     FLeft=..[_|[IdLeft|_]],
		     FRight=..[_|[IdRight|_]],
		     IdLeft\==Id1,  IdLeft\==Id2,
		     IdRight\==Id1, IdRight\==Id2
		    ),NonAdjacentRelations),
	union(NonAdjacentRelations,NewRelationsWithNewFunction,NewRelations),  %the new relations for the next reduction

%+Presentation purposes
	Level2 is Level+1,
%-Presentation purposes

	do_generate_qw_by_Relations(NewRelations,NewFunctionSet,Function,Level2).
	
	
do_generate_qw_by_Relations(Relations,Functions,_,_):- %If the execution gets here thuse there was an anomaly (e.g. deadlock [diapo 'Deadlock patterns'])
        Relations=[Relation|_],
        Relation=..[_,F1,F2],
        merge_dtfs(F1,F2,NewFunction),
        difference(Functions,[F1,F2],RestOfFunctions),
        findall(Rel,( member(OtherF,RestOfFunctions),
                      do_relations([[NewFunction,OtherF]],[Rel]),
		      Rel=..[fail|_]
                     ),NewRelations),	
	NewRelations\==[],!,
	print_relation_derivation(Relation,NewFunction,Relations,NewRelations),
	nl,write('-------FAIL-------'),
	print_relation_short(Relation),fail.



%QW GENERATION BY FUNCTIONS COMBINATIONS
generate_qw_by_Functions(Functions,Function):-
	permutation(Functions,PermutedFunctions),
	clear_dtf_ids,
	nl,write('   PERM: '),
        findall(_,(nth(_,PermutedFunctions,Fun),
                   print_function_short(Fun,Output)
                  ,write(Output),write(', ')
                  ),_),
	do_generate_qw_by_Functions(PermutedFunctions,Function,2).

do_generate_qw_by_Functions([Function],Function,_). %Base case
do_generate_qw_by_Functions(Functions,Function,Level):-
	length(Functions,L),
        L>1,
        nl,write('============================================'),
        nl,write('\t   FUNCTIONS:\t'),
        findall(_,(nth(_,Functions,Fun),
                   print_function_short(Fun,Output),
                   write(Output),write(', ')
                  ),_),
	Functions=[F1,F2|TailFunctions],
	relation([F1,F2],Relation),
        nl,write('\t    RELATION:\t'),print_relation_short(Relation),
        Relation=..[RelationType,Function1,Function2],
	RelationType\==fail,!,
        arg(1,Function1,Id1),
        arg(1,Function2,Id2),
        merge_dtfs(Function1,Function2,NewFunction),
%-
        arg(1,NewFunction,IdNew),
        arg(6,NewFunction,SubQW),
        qw_pattern(RelationType,CompositionPattern),
        compose_qw(CompositionPattern,Function1,Function2,SubQW),
        nl,write('\t NEWFUNCTION:'),write('\t'),write(IdNew),write(' = merge('),write(Id1),write(', '),write(Id2),write(')'),
                                 %nl,write('\t\t\t'),write(NewFunction),
        nl,write('\t          QW:'),write('\t'),write(SubQW),
%-
	union(TailFunctions,[NewFunction],NewFunctionSet),
        Level2 is Level+1,
        do_generate_qw_by_Functions(NewFunctionSet,Function,Level2).

do_generate_qw_by_Functions(Functions,_,_):-
        Functions=[F1,F2|_],
        relation([F1,F2],Relation),
	Relation=..[fail|_],!,
        nl,write('-------FAIL------- '),
        print_relation_short(Relation),fail.

	

%QW GENERATION BY RELATIONS COMBINATIONS

%Functor called by the main directive (e.g., test/2)
%[diapo 'QW Generation algorithm']
%PARAMETERS
%[+]Relations: List of relations
%[+]Functions: List of functions
%[?]Function: resulting function of the form 
%               function(id,
%                        Aliases,
%                        Expression,
%                        Projection,
%                        QW) // This is not part of the function definition but is used to
%                            //carry the query workflow composition through the function reduction
%
%DESCRIPTION:
% The generate_qw_by_Relations(Relations,Functions,Function) succeds if the Function is a 
%reduction of the functions of Functions which relations among them are Relations
generate_qw_by_GraphReduction(Relations,Functions,Function):-
	nl,write('&&& Original graph     &&&'),
	print_matrix_of_relations(Relations,2),
	no_deadlock_relations(Relations,NoDeadlockRelations),
	nl,write('&&& No-deadlock graph  &&&'),
	print_matrix_of_relations(NoDeadlockRelations,2),
        nl,write('   ITERATION: '),
        findall(_,(nth(_,NoDeadlockRelations,Rel)
                   ,print_relation_short(Rel,Output),
                    write(Output),write(', ')
                  ),_),
        do_generate_qw_by_GraphReduction(NoDeadlockRelations,Functions,Function,1). %this is the core of the algo [diapo 'QW generation by graph reduction']



%Functor called by generate_qw_by_Relations/3
%[diapo 'QW Generation algorithm']
%PARAMETERS
%[+]Relations: cf. generate_qw_by_Relations/3
%[+]Functions: cf. generate_qw_by_Relations/3
%[?]Function: cf. generate_qw_by_Relations/3
%[+]Level: integer with the level of the reduction. Just for presentation purposes
%
%DESCRIPTION: This is the core of the generation algorithm cf.generate_qw_by_Relations/3
do_generate_qw_by_GraphReduction(_,[Function],Function,_). %base case: if there is only one function in the Functions thus it has finished

do_generate_qw_by_GraphReduction(Relations,Functions,Function,Iteration):-
        length(Functions,L), L>1,
	nl,write(Functions),
	nl,write(Relations),
	next_dtf(Functions,Relations,NextFunction),
	
	((Iteration=1,clear_dtf_ids,!)
	 ;
	 true),

	nl,write('============================================ ITERATION: '),write(Iteration),
	nl,write('     NEXT FUNCTION: '),print_function_short(NextFunction),
	choose_next_dtf_to_merge(NextFunction,Relations,Relation,FunctionToMerge),
	nl,write('FUNTCTION TO MERGE: '),print_function_short(FunctionToMerge),
	nl,write('             GRAPH: '),
	no_deadlock_relations(Relations,NoDeadlockRelations),
	print_matrix_of_relations(NoDeadlockRelations,2),nl,

	arg(1,NextFunction,IdNextF),
	arg(1,FunctionToMerge,IdFToMerge),
	merge_dtfs(NextFunction,FunctionToMerge,NewFunction),
	
	%arg(6,NewFunction,IdNewF),

        arg(6,NewFunction,SubQW), %  gets SubQW variable. When the NewFunction is created SubQW is
                                  %unbounded (i.e, it has no an associated quwey workflow (c.f. compose_qw/4)
	Relation=..[RelationType,_,_],

        qw_pattern(RelationType,CompositionPattern), %  chose a composition pattern according with the
                                             %RelationType [diapo 'Composition patterns', 'QW Generation algorithm']
        compose_qw(CompositionPattern,NextFunction,FunctionToMerge,SubQW), %  The subquery workflows of F1 and F2 are joined to
                                                 %the composition pattern. Thus the SubQW is bounded with the new QW

	arg(7,NewFunction,EQ),
	make_equation(Relation,EQ),
	nl,write('          EQUATION: '),write(EQ),

%+Presentation purposes
	nl,write('      NEW FUNCTION: '),print_function_short(NewFunction),write('='),print_relation_short(Relation,RelationShort),write(RelationShort),
        nl,write('                QW: '),write(SubQW),
%-Presentation purposes

%+Adjacent Relations
	findall(AdjacentRelation,(member(AdjacentRelation,NoDeadlockRelations),
				   AdjacentRelation\==Relation,
				  (AdjacentRelation=..[_,AdjacentFunction,NextFunction];
				   AdjacentRelation=..[_,NextFunction,AdjacentFunction];
				   AdjacentRelation=..[_,AdjacentFunction,FunctionToMerge];
				   AdjacentRelation=..[_,FunctionToMerge,AdjacentFunction]
				  ),
				  arg(1,AdjacentFunction,IdAdjacentF),
				  IdAdjacentF\==IdNextF,
				  IdAdjacentF\==IdFToMerge
				 ),
		AdjacentRelations),
	nl,write('     ADJACENT RELS: '),
	findall(_,(member(AR,AdjacentRelations), nl,write('\t\t'),print_relation_short(AR)),_),
%-Adjacent Relations
	
%+Adjacent Functions
	findall(AdjacentFunction,(member(AdjacentRelation,AdjacentRelations),
				  (AdjacentRelation=..[_,AdjacentFunction,NextFunction];
				   AdjacentRelation=..[_,NextFunction,AdjacentFunction];
				   AdjacentRelation=..[_,AdjacentFunction,FunctionToMerge];
				   AdjacentRelation=..[_,FunctionToMerge,AdjacentFunction]
				  )
				 ),
		AdjacentFunctions),
	sort(AdjacentFunctions), %eliminate duplicates
	nl,write('     ADJACENT FUNS: '),
	findall(_,(member(AF,AdjacentFunctions), print_function_short(AF),write(', ')),_),
%-Adjacent Functions
	
%+Compute the relations of the NewFunction with each AdjacentFunction
        findall(Rel,( member(OtherF,AdjacentFunctions), %for each reminding function, the relations with the NewFunction are calculated
                      do_relations([[NewFunction,OtherF]],[Rel]),
                      \+Rel=..[fail|_]        %if the resulted relation has a type 'fail' thus there is an anomaly
                    ),
		RelationsWithNewFunction),
	
	length(AdjacentFunctions,N),
	length(RelationsWithNewFunction,N),
	nl,write('     NEW RELATIONS: '), print_matrix_of_relations(RelationsWithNewFunction,2),nl,
%-Compute the relations of the NewFunction with each AdjacentFunction

%+New Functions and Relations sets
	difference([NewFunction|Functions],[NextFunction,FunctionToMerge],NewFunctionsSet),
	nl,write('   NEW FUNCTION SET: '),
	findall(_,(member(F,NewFunctionsSet), print_function_short(F), write(',')),_),

	append(NoDeadlockRelations,RelationsWithNewFunction,AllRelations),
	difference(AllRelations,[Relation|AdjacentRelations],NewRelationsSet),
	nl,write('          NEW GRAPH: '), print_matrix_of_relations(NewRelationsSet,2),nl,

%-New Functions and Relations sets
	Iteration2 is Iteration+1,
	do_generate_qw_by_GraphReduction(NewRelationsSet,NewFunctionsSet,Function,Iteration2).
	


next_dtf(Functions,Relations,NextFunction):-
	member(NextFunction,Functions),
	findall(Rel,( member(Rel,Relations),
		      Rel=..[dependent,_,NextFunction]),
		DependentRelations),
         DependentRelations=[].

next_dtf(Functions,Relations,NextFunction):-
	member(NextFunction,Functions),
	findall(Rel,( member(Rel,Relations),
	              Rel=..[concurrent,_,NextFunction]%,
		      %member(NextFunction,Fs)
		     ),
		 ConcurrentRelations),
        ConcurrentRelations\==[].

choose_next_dtf_to_merge(Function,Relations,Relation,FunctionToMerge):-
	findall(Rel,( member(Rel,Relations),
		      Rel=..[dependent,Function,F],
	              findall(OtherRel,( member(OtherRel,Relations),
			                 OtherRel=..[dependent,OtherFunction,F],
					 OtherFunction\==Function,!),
		              OtherDependentRelations),
		      OtherDependentRelations=[]
		    ),
		DependentRelations),
	member(Relation,DependentRelations),
	Relation=..[dependent,Function,FunctionToMerge].

choose_next_dtf_to_merge(Function,Relations,Relation,FunctionToMerge):-
	findall(Rel,( member(Rel,Relations),
		      (Rel=..[concurrent,Function,F];
		       Rel=..[concurrent,F,Function])
		  ),
		IndependentRelations),
        member(Relation,IndependentRelations),
        (Relation=..[concurrent,Function,FunctionToMerge]
	 ;
	 Relation=..[concurrent,FunctionToMerge,Function]).

choose_next_dtf_to_merge(Function,Relations,Relation,FunctionToMerge):-
	findall(Rel,( member(Rel,Relations),
		      (Rel=..[independent,Function,F];
		       Rel=..[independent,F,Function])
		  ),
		IndependentRelations),
        member(Relation,IndependentRelations),
        (Relation=..[independent,Function,FunctionToMerge]
	 ;
	 Relation=..[independent,FunctionToMerge,Function]).


make_equation(Relation,EQ):-
	Relation=..[RelationType,LeftF,RightF],
	arg(7,LeftF,LeftEQ),
	arg(7,RightF,RightEQ),
	((RelationType=dependent,  !, Op=('>>') );
         (RelationType=concurrent, !, Op=('><') );
         (RelationType=independent,!, Op=('||') )
        ),
	concat_all_atoms(['(',LeftEQ,' ',Op,' ',RightEQ,')'],EQ).

